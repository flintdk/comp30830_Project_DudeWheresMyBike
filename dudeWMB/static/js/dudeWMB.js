"use strict";

google.load("visualization", 'current', {packages:["corechart"]});

// Define modes as kind of enumerations in javascript
const MODE_AVAILABLE_BIKES = "ModeAvailableBikes";
const MODE_AVAILABLE_SPACES = "ModeAvailabeSpaces";

// Validity Window for Global Station Data
// (We don't want to load station information every time the user click any button
// as loading that data is expensive (takes a long time) and it negatively impacts
// the end user experience.  This constant is "how long we believe data should be valid"
const STATION_DATA_VALIDITY_TIME_MS = 300000;  // 300000ms = 5 mins

// varGlobStations is a array that contains the json objects for each station
var varGlobStations;
// varGlobStationSelected contains station data for the selected station
var varGlobStationSelectedIndex;
// varGlobStationsLUPTimestamp when was our global data last loaded?
var varGlobStationsLUPTimestamp = null;

// varGlobActiveMode represents the active user mode (avalailable bikes, available spaces)
var varGlobActiveMode = MODE_AVAILABLE_BIKES;
// varGlobPredictionInHours indicates the data prediction we want to get in x hours time, where hours == 0 stands for current time 
var varGlobPredictionInHours = 0;
//  *** THIS IS A TEMP WORKAROUND ***
// Going forward we believe predictions should be generated by a back-end process
// But for now - they are done live.
var varGlobForceReloadPredictionHasChanged = false;

// varGlobMap allows to access the created map globally
var varGlobMap;
// We want only one info window open at a time.  We hold the opened (active)
// infoWindow in a variable so we can access it's .close() method in click event
// of each marker.
var varGlobInfoWindow;
// We want to keep a list of markers we've created, so we can make them display
// etc. as we wish.
var varGlobMarkers;

//-----------------------------------------------------------------------------
// Function onLoad is invoked when the website (DOM) is loaded the first time
//-----------------------------------------------------------------------------
// This function is called onload.  It's the 'parent process' if you like that
// kicks off all the work...
async function onLoad() {

    // This is a one-off function ("on page load") - we do need data at this point
    // to build drop-downs etc., so go get it.
    // (loadDataAsRequired is an asycn function - it pauses while data loads)
    await loadDataAsRequired();

    // Add event listener to mode buttons 
    // *** REMEMEBER *** onSetMode will also call initMap
    document.getElementById("button_available_bikes").addEventListener("click", function() {
        onSetMode(MODE_AVAILABLE_BIKES);
      });
    document.getElementById("button_available_spaces").addEventListener("click", function() {
        onSetMode(MODE_AVAILABLE_SPACES);
    });

    populateStationSelect();

    document.getElementById("futureTime").innerHTML = new Date().toLocaleString();

    // set the default mode
    // and call initMap (this initialises display on start)
    onSetMode(MODE_AVAILABLE_BIKES);

    // Occupancy is for the last seven days
    // This method calls a second URL to load the last seven days occupancy from db
    displayOccupancyChart(16);
}

//-----------------------------------------------------------------------------
// Load Data - IFF It Is required!
//-----------------------------------------------------------------------------
// Expect argument 'noHoursInFuture' to be int..
async function loadDataAsRequired() {
    // We load the stations on page load as well as here in initMap - whatever event occurs first 
    let url = 'stations'
    if (varGlobPredictionInHours != null && varGlobPredictionInHours > 0) {
        url += "?hours_in_future=" + varGlobPredictionInHours
    }

    //if  new Date(new Date().getTime() + this.value*60*60*1000).toLocaleString();
    let checkTime = new Date(Date.now() - STATION_DATA_VALIDITY_TIME_MS);

    if (varGlobStationsLUPTimestamp == null  // If this is null... then this is initial page load
        ||
        (varGlobStationsLUPTimestamp != null && checkTime > varGlobStationsLUPTimestamp)
        ||
        varGlobForceReloadPredictionHasChanged
        )
    {
        //console.log("loadDataAsRequired: fresh data load in progress");
        //console.trace()
        // Our data has either:
        //  -> Never been loaded (varGlobStationsLUPTimestamp == null)
        // ... or ...
        //  -> Is stale (checkTime > varGlobStationsLUPTimestamp)
        varGlobStations = await getStationsJson(url);
        //console.log("in loadDataAsRequired, data retrieved!!" + varGlobStations);

        varGlobStationsLUPTimestamp = new Date();
        varGlobForceReloadPredictionHasChanged = false;
    }
    //console.log("loadDataAsRequired: end of function (data loaded)");
}

//-----------------------------------------------------------------------------
// Mode control - 'available bikes' OR 'available spaces' 
//-----------------------------------------------------------------------------
function onSetMode(mode) {
    if (mode === MODE_AVAILABLE_BIKES) {
        varGlobActiveMode = MODE_AVAILABLE_BIKES;
        document.getElementById("button_available_bikes").style.backgroundColor = "green"
        document.getElementById("button_available_spaces").style.backgroundColor = "lightgreen"
    } else if (mode === MODE_AVAILABLE_SPACES) {
        varGlobActiveMode = MODE_AVAILABLE_SPACES;
        document.getElementById("button_available_bikes").style.backgroundColor = "lightgreen"
        document.getElementById("button_available_spaces").style.backgroundColor = "green"
    }

    // Init map and coloured icons when user mode is changing
    initMap();

    // Also update station details
    displayStationDetails();
}

//-----------------------------------------------------------------------------
// Function to initialize and add the map/redraw the map
//-----------------------------------------------------------------------------
// Expect argument 'noHoursInFuture' to be int..
async function initMap() {
    loadDataAsRequired();

    // Location of Dublin
    const dublin = { lat: 53.350140, lng: -6.266155 };
    // Create new map, centered at Dublin.
    // Creating a new map will remove all markers from the existing map and 
    // let us start afresh, so no need to, for e.g., remove existing markers
    // when displaying a prediction.
    varGlobMap = new google.maps.Map(document.getElementById("map"), {
        zoom: 13,
        center: dublin,
    });
//########################################################################################################
    if (document.getElementById("mapContentDescription") != null) {
        document.getElementById("mapContentDescription").innerHTML = "tommmy tommy";
    } 

    createMarkers();
}

//-----------------------------------------------------------------------------
// Bike icon selection according to occupancy and user mode 
//-----------------------------------------------------------------------------
function getBikeIconUrl(mode, station) {

    // Threshold values defined in percentage to select coloured bike icons accordingly
    const THRESHOLD_GREEN = 70.0;
    const THRESHOLD_RED = 10.0;

    // Relative paths to bike icons
    const PATH_BIKE_ICON = "img/bikeIcon.svg";
    const PATH_BIKE_ICON_GREEN = "img/bikeIconGreen.png";
    const PATH_BIKE_ICON_ORANGE = "img/bikeIconOrange.png";
    const PATH_BIKE_ICON_RED = "img/bikeIconRed.png";
 
    let iconPathSelected = PATH_BIKE_ICON;
    //console.log("In getbikeIcon : " + JSON.stringify(station));
    // If station is closed then show default icon
    // TEMPORARY WORK AROUND: Our predictions don't currently 
    if (!(station.occupancy.status == 'OPEN' || station.occupancy.status == '-')) {
        iconPathSelected = PATH_BIKE_ICON;
    } 
    // Select bike icons to user mode and occupancy accordingly
    // If user mode is 'available bikes' then... 
    else if (mode === MODE_AVAILABLE_BIKES) {
        if (getPercentage(station.occupancy.available_bikes, station.bike_stands) >= THRESHOLD_GREEN) {
            iconPathSelected = PATH_BIKE_ICON_GREEN;
        } 
        else if (getPercentage(station.occupancy.available_bikes, station.bike_stands) <= THRESHOLD_RED) {
            iconPathSelected = PATH_BIKE_ICON_RED;
        }
        else {
            iconPathSelected = PATH_BIKE_ICON_ORANGE;
        } 
    } 
    // If user mode is 'available bikes' then... 
    else if (mode === MODE_AVAILABLE_SPACES) {
        if (getPercentage(station.occupancy.available_bike_stands, station.bike_stands) >= THRESHOLD_GREEN) {
            iconPathSelected = PATH_BIKE_ICON_GREEN;
        } 
        else if (getPercentage(station.occupancy.available_bike_stands, station.bike_stands) <= THRESHOLD_RED) {
            iconPathSelected = PATH_BIKE_ICON_RED;
        } 
        else {
            iconPathSelected = PATH_BIKE_ICON_ORANGE;
        } 
    }
    // console.log("available bikes: " + stationState.available_bikes);
    // console.log("available bike stands: " + stationState.available_bike_stands);
    // console.log("stands bikes: " + stationState.bike_stands);
    // console.log("stands status: " + stationState.status);
    // console.log(iconPathSelected);
    return iconPathSelected;

}

// Helper function for 'getBikeIconUrl'
function getPercentage(value, max) {
    let percentage = 0.0;
    if (max != 0) {
        percentage = (value / max) * 100;
    } else {
        console.log("Error: Zero Division in getPercentage()");
    }

    return percentage;
}

//-----------------------------------------------------------------------------
// Create markers that are displayed on the map
//-----------------------------------------------------------------------------
// Note: The coloured bike icon (black, green, orange, red) may change when the user mode is changed,
// depending on the availability of available bikes, spaces
// That's why this function is also called if the user mode changes

function createMarkers() {
    // Every time we're called upon to create markers, create a fresh array to
    // store them in...
    varGlobMarkers = [];

    for (let key in varGlobStations) {
        let station = varGlobStations[key];

        // Create table containing information about the station...
        let contentString = '<div id="content"><span id="markerStationName">' + station.stationName + '</span></div>' +
            '<div id="station_details"><table>' +
            '<tr><td>Station name:</td><td>' + station.stationName + '</td></tr>' +
            '<tr><td>Address:</td><td>' + station.address + '</td></tr>' +
            '<tr><td>Latitude:</td><td>' + station.latitude + '</td></tr>' +
            '<tr><td>Longitude:</td><td>' + station.longitude + '</td></tr>' +
            '<tr><td>Banking:</td><td>' + station.banking + '</td></tr>' +
            '<tr><td>Total bike stands:</td><td>' + station.bike_stands + '</td></tr>' +
            '<tr><td>Available bike stands:</td><td>' + station.occupancy.available_bike_stands + '</td></tr>' +
            '<tr><td>Available bikes:</td><td>' + station.occupancy.available_bikes + '</td></tr>' +
            '</div>';

        //console.log(station.stationName, station.number);
        let marker = new google.maps.Marker({
            position: {
                lat: station.latitude,
                lng: station.longitude
            },
            map: varGlobMap,
            icon: {
                url: getBikeIconUrl(varGlobActiveMode, station),
                scaledSize: new google.maps.Size(42, 42)
            },
            title: station.stationName,
            station_number: station.number,
            station_index: key, // add key as index so that marker correlates with the array index in station data
            content_string: contentString  // store the content string IN the marker, so we can access it wherever...
        });
        
        // Add listener so that we can add actions that will be performed when clicking on a marker
        marker.addListener("click", () => {
            // When this marker is clicked - pop it's reference in to the global
            // holder - and display again.
            varGlobStationSelectedIndex = marker.station_index;
            displayStationDetails();
          }
        );
        // With an array of markers stored in scope, we can play with them, make
        // them display etc. from other functions.
        varGlobMarkers.push(marker);
    }
}

//-----------------------------------------------------------------------------
// Display station details such as weather info and occupancy 
//-----------------------------------------------------------------------------
async function displayStationDetails() {

    // Store the index of the selected station within the station array
    // On page load, no station is selected:
    if (varGlobStationSelectedIndex == null) {
        varGlobStationSelectedIndex = 0;  // select the first station in the list...
    }
    else {
        displayMapMarkerInfoWindow(varGlobStationSelectedIndex);
    }

    // Update station name headline
    //console.log("stationIndex: " + stationIndex.toString());
    //console.log(StationDataPredicted);
    //console.log(url);
    //document.getElementById('selectedStation').innerHTML = StationDataPredicted[stationIndex].stationName;
    document.getElementById('selectedStation').innerHTML = varGlobStations[varGlobStationSelectedIndex].stationName;

    displayOccupancyChart(varGlobStationSelectedIndex);
    displayWeatherIcon(varGlobStationSelectedIndex);
    
}

// Populate information window for selected marker
function displayMapMarkerInfoWindow(stationIndex) {
    // Don't update the map if the global markers windows hasn't updated yet.
    if (varGlobMarkers != null && varGlobMarkers.length > 0) {
        for (let i = 0; i < varGlobMarkers.length; i++) {
            let marker = varGlobMarkers[i];

            if (marker.station_index == stationIndex) {
                //console.log("found marker" + marker.title)
                //Close active window if exists
                if (varGlobInfoWindow != null) {
                    varGlobInfoWindow.close();
                    varGlobInfoWindow = new google.maps.InfoWindow();
                }
                else {
                    // If this is the very first info window... create a fresh one.
                    varGlobInfoWindow = new google.maps.InfoWindow();
                }
                varGlobMap.setZoom(14);
                //console.log(marker.getPosition().lat() + " - " + marker.getPosition().lng())
                varGlobMap.setCenter(marker.getPosition());
                varGlobInfoWindow.setContent(marker.content_string);
                varGlobInfoWindow.open(varGlobMap, marker);
            }
        }
    }
}

//-----------------------------------------------------------------------------
// Display station weather detials such as weather icon, temperature, etc. 
//-----------------------------------------------------------------------------
function displayWeatherIcon(stationIndex) {
    /* Function to display weather icon for current/future weather description
    as slider is moved
    */
    // Relative paths to weather category icons
    // Default Image for any errors etc.
    const PATH_TEMP_ICON = "img/weather_forecast_icon.png";
    // Icon paths for different weather categories
    const PATH_ICON_BROKEN_CLOUDS = "img/broken_clouds.svg";
    const PATH_ICON_CLEAR_SKY = "img/clear_sky.svg";
    const PATH_ICON_FEW_CLOUDS = "img/few_clouds.svg";
    const PATH_ICON_FOG = "img/fog.svg";
    const PATH_ICON_HAZE = "img/haze.svg";
    const PATH_ICON_HVY_INT_RAIN = "img/heavy_intensity_rain.svg";
    const PATH_ICON_LIGHT_INT_DRIZ = "img/light_intensity_drizzle.svg";
    const PATH_ICON_LIGHT_INT_DRIZ_RAIN = "img/light_intensity_drizzle_rain.svg";
    const PATH_ICON_LIGHT_INT_SHOW_RAIN = "img/light_intensity_shower_rain.svg";
    const PATH_ICON_LIGHT_RAIN = "img/light_rain.svg";
    const PATH_ICON_MIST = "img/mist.svg";
    const PATH_ICON_MODERATE_RAIN = "img/moderate_rain.svg";
    const PATH_ICON_OVERCAST_CLOUDS = "img/overcast_clouds.svg";
    const PATH_ICON_SCATTERED_CLOUDS = "img/scattered_clouds.svg";
 
    let weatherIconPath = PATH_TEMP_ICON;

    let station = varGlobStations[stationIndex];

    // Checking current and future weather description to update path to weather icon
    if (station.weather.description == 'broken clouds') {
        weatherIconPath = PATH_ICON_BROKEN_CLOUDS;
    } else if(station.weather.description == 'clear sky') {
        weatherIconPath = PATH_ICON_CLEAR_SKY;
    } else if(station.weather.description == 'few clouds') {
        weatherIconPath = PATH_ICON_FEW_CLOUDS;
    } else if(station.weather.description == 'fog') {
        weatherIconPath = PATH_ICON_FOG;
    } else if(station.weather.description == 'haze') {
        weatherIconPath = PATH_ICON_HAZE;
    } else if(station.weather.description == 'heavy intensity rain') {
        weatherIconPath = PATH_ICON_HVY_INT_RAIN;
    } else if(station.weather.description == 'light intensity drizzle') {
        weatherIconPath = PATH_ICON_LIGHT_INT_DRIZ;
    } else if(station.weather.description == 'light intensity drizzle rain') {
        weatherIconPath = PATH_ICON_LIGHT_INT_DRIZ_RAIN;
    } else if(station.weather.description == 'light intensity shower rain') {
        weatherIconPath = PATH_ICON_LIGHT_INT_SHOW_RAIN;
    } else if(station.weather.description == 'light rain') {
        weatherIconPath = PATH_ICON_LIGHT_RAIN;
    } else if(station.weather.description == 'mist') {
        weatherIconPath = PATH_ICON_MIST;
    } else if(station.weather.description == 'moderate rain') {
        weatherIconPath = PATH_ICON_MODERATE_RAIN;
    } else if(station.weather.description == 'overcast clouds') {
        weatherIconPath = PATH_ICON_OVERCAST_CLOUDS;
    } else if(station.weather.description == 'scattered clouds') {
        weatherIconPath = PATH_ICON_SCATTERED_CLOUDS;
    } else {
        weatherIconPath = PATH_TEMP_ICON;
    }
    document.getElementById("img-weather").src=weatherIconPath;
    // Temperature from openweather.org is in Kelvin - change to degrees C
    document.getElementById("sliderTemp").innerHTML
        = (station.weather.temp - 273.15).toFixed(1) + "&#176;C";
    //console.log(station.weather.description);

    return;
}

// document.getElementById("img-weather").src

//-----------------------------------------------------------------------------
// Display station occupancy chart 
//-----------------------------------------------------------------------------
async function displayOccupancyChart(stationIndex) {

    let station = varGlobStations[stationIndex];

    let occupancyFetchPromise = fetch('/occupancy/' + station.id);
    // Define our event handler for what to do when the promise is fulfilled...
    occupancyFetchPromise.then(
        response => {
            //console.log(`Received response: ${response.status}`);

            let responseTextPromise = response.text();
            responseTextPromise.then (
                responseText => {
                    let occupancyData = JSON.parse(responseText)
                    //console.log("occupancyData: " + JSON.stringify(occupancyData));

                    // Google Visualisation API Reference:
                    //   https://developers.google.com/chart/interactive/docs/reference#dataparam

                    // Google Chart Tools charts require data to be wrapped in a
                    // JavaScript class called google. visualization. DataTable

                    // Can we load the json data directly into a Data Table??
                    //let dataTableData = google.visualization.arrayToDataTable(occupancyData);
                    var dataTable = new google.visualization.DataTable(occupancyData);

                    google.charts.load("current", {packages:["corechart"]});

                    // var options = {'title':'My Average Day'};
                    var options = {
                        title: 'Occupancy for ' + station.stationName + ', Last Seven Days',
                        legend: { position: 'none' },
                        width: 400,
                        height:300,
                        hAxis: {
                            format: 'yy/MM/dd',
                            gridlines: {count: 7}
                        },
                        vAxis: {
                            gridlines: {color: 'none'},
                            minValue: 0
                        }
                    };
                
                    //var chart = new google.visualization.Histogram(document.getElementById('occupancy_histogram'));
                    //var chart = new google.visualization.PieChart(document.getElementById('occupancy_histogram'));
                    //var chart = new google.visualization.BarChart(document.getElementById('occupancy_histogram'));
                    var chart = new google.visualization.ColumnChart(document.getElementById('occupancy_histogram'));
                    chart.draw(dataTable, options);
                    
                }
            )
        }
    );

}

//-----------------------------------------------------------------------------
// Get station data
//-----------------------------------------------------------------------------
// What follows are a pair of functions to:
//   -> first get
//   -> and then display
// our stations data in json format.  We might never use these once the dudeWMB
// site is final. But its a helpful exercise to make sure we can access JSON data
// sourced from an endpoint in the dudeWMB Flask app, using JavaScript fetch()
async function getStationsJson(url) {
    // There is a good example on using JavaScript fetch here:
    //      https://www.javascripttutorial.net/javascript-fetch-api/
    // I chose not to reproduce that content here (because it's much easier to
    // read on the web with pictures etc.).  If you want to explore JavaScript
    // fetch, please start there.

    // Key concept: A Promise is an object representing the eventual completion or failure of an asynchronous operation.
    try {
        let stations = await fetch(url);
        // console.log(stations.status); // 200
        // console.log(stations.statusText); // OK

        // In the following line, the json() method of the Response interface takes
        // a Response stream and reads it to completion. It returns a promise which
        // resolves with the result of parsing the body text as JSON.
        // *** Note that despite the method being named json(), the result is not
        //     JSON but is instead the result of taking JSON as input and parsing
        //     it to produce a JavaScript object!
        if (stations.status == 200) {
            let stationsJson = await stations.json();
            return stationsJson;
        }
        return null // Result undefined
    } catch (error) {
        console.log(error);
    }
}

//-----------------------------------------------------------------------------
// Function to dynamically create the dropdown content for station selection
//-----------------------------------------------------------------------------
function createStationDropdownContent() {
    // for example: <a href="#" onclick="onUpdateStationInfo(stationId)">SMITHFIELD NORTH</a>
    // where stationId is the index in the station-object

//    console.log(varGlobStations)
    var output = "";
    for (let i = 0; i < varGlobStations.length; i++) {
        output += '<a href="#" ';
        output += 'onclick="onStationSelected(';
        output += "'" + i + "',";  
        output += ')">';
        output += varGlobStations[i].stationName; 
        output += "</a>";
    }
    document.getElementById('dropdownContentStation').innerHTML = output;

}

function populateStationSelect() {
    var output = "";
    for (let i = 0; i < varGlobStations.length; i++) {
        output += "<option onclick=\"onStationSelected('" + i + "')\">";
        output += varGlobStations[i].stationName; 
        output += "</option>";
    }
    //console.log("generated content is..." + output)
    document.getElementById('stationSelect').innerHTML = output;
}

function onStationSelected(stationIndexInGlobStationsList) {
    // Store the index of the selected station within the station array
    varGlobStationSelectedIndex = stationIndexInGlobStationsList;

    // Also update station details
    displayStationDetails(varGlobStationSelectedIndex);

}

//-----------------------------------------------------------------------------
// Range slider for time prediction
//-----------------------------------------------------------------------------

var slider = document.getElementById("sliderTimePrediction");
// On event call which is invoked each time you drag the slider handle
slider.onchange = function() {
    // Write time prediction in hours to a global variable
    varGlobPredictionInHours =  this.value;
    // Force a reload of the data at the future datetime
    varGlobForceReloadPredictionHasChanged = true;

    // Add these hours to the current date & time and convert it into a string
    let predictedDateTime = new Date(new Date().getTime() + this.value*60*60*1000).toLocaleString();
    // Update display element

    document.getElementById("futureTime").innerHTML = predictedDateTime;

    // Also update station details
    displayStationDetails(varGlobStationSelectedIndex);

    // Redraw the map and coloured icons to show the predicted occupancies etc.
    // when the slider changes.
    initMap();

    // debugging only!
    // console.log("slider value:" + slider.value.toString());
    // console.log(predictedDateTime);
}